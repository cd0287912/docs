### GO 函数

函数变量作用域：
全局变量：定义在函数外部的变量，在程序整个运行周期内都有效
局部变量：定义在函数内部的变量，只能在函数内部使用

```go
// 函数的定义
// 固定参数
func subFn(x, y int) int {
	return x - y
}
// 可变参数- x是一个切片
func sumFn(x ...int) {
	var sum int
	for _, v := range x {
		sum += v
	}
	fmt.Println(sum)
}
// 一次返回多个值
func calc(x int, y int) (int, int) {
	sum := x + y
	sub := x - y
	return sum, sub
}
// 返回值命名，函数体内可以直接使用，不需要再声明
func calc(x int, y int) (sum int, sub int) {
	sum = x + y
	sub = x - y
	return
}
```

```go
// 练习：排序
func sortIntAsc(slice []int) []int {
	for i := 0; i < len(slice); i++ {
		for j := i + 1; j < len(slice); j++ {
			if slice[i] > slice[j] {
				temp := slice[j]
				slice[j] = slice[i]
				slice[i] = temp
			}
		}
	}
	return slice
}
```

声明一个函数类型,函数也可以作为参数、返回值等等
函数也可以是匿名函数

```go
// 声明一个函数类型
// type typeName func(paramsType) returnType
type calc func(int, int) int

// 匿名函数
var calcFn calc = func(x, y int) int {
	return x + y
}

// 函数作为返回值、形成闭包
func calcByType(initCount int) calc {
	count := initCount
	return func(x, y int) int {
		count = x + y
		return count
	}
}
```

defer语句：讲其后面跟随的语句进行延迟处理。在defer归属的函数即将返回时，将延迟处理的语句按defer定义的逆序进行执行，即先defer的语句最后被执行，最后defer的语句优先执行。

defer注册要延迟执行的函数时，改函数的所有参数都要确定其值

```go
// defer简单使用
func main() {
	fmt.Println("start")
	defer fmt.Println(1)
	defer fmt.Println(2)
	defer fmt.Println(3)
	fmt.Println("end")
}

// 使用匿名函数来defer一组操作
func main() {
	fmt.Println("start")
	defer func() {
		fmt.Println(1)
		fmt.Println(2)
		fmt.Println(3)
	}()
	fmt.Println("end")
}

// 匿名返回值和命名返回值区别：
func defereDemo1() int {
	var a int
	defer func() {
		a++
	}()
	return a
}
func defereDemo2() (a int) {
	defer func() {
		a++
	}()
	return a
}
// defer练习例子
func calc(index string, a, b int) int {
	ret := a + b
	fmt.Println(index, a, b, ret)
	return ret
}

func main() {
	x := 1
	y := 2
	defer calc("AA", x, calc("A", x, y))
	x = 10
	defer calc("BB", x, calc("B", x, y))
	y = 20

	// 重点：defer注册要延迟执行的函数时，改函数的所有参数都要确定其值

	// 注册顺序
	// defer calc("AA", x, calc("A", x, y))
	// defer calc("BB", x, calc("B", x, y))

	// 执行顺序
	// defer calc("BB", x, calc("B", x, y))
	// defer calc("AA", x, calc("A", x, y))

	// 第一步：注册执行，确定其值
	// calc("A", x, y)  A 1 2 3
	// calc("B", x, y)  B 10 2 12
	// 第二步：运行执行顺序
	// defer calc("BB", x, calc("B", x, y)) BB 10 12 22
	// defer calc("AA", x, calc("A", x, y)) AA 1  3  4

}
```

panic 与 recover 来处理异常情况
panic可以在任何地方触发，recover只能在defer调用的函数中有效

```go
func calc(x, y int) int {
	defer func() {
		err := recover()
		if err != nil {
			fmt.Println("error:====>", err)
		}
	}()
	if y == 0 {
		panic("被除数不能为0哦~")
	}
	return x / y
}
```
