### GO 结构体struct和JSON相互转换

结构体与JSON之间的相互转换，场景一是给前端提供api接口数据

golang中的序列化与反序列化主要通过“encoding/json”包中的json.Marshal()和json.Unmarshal()函数实现。

- json.Marshal()函数：将Go语言中的结构体、数组、切片等数据类型转换为JSON格式的字符串。
- json.Unmarshal()函数：将JSON格式的字符串转换为Go语言中的结构体、数组、切片等数据类型。

```go
type Student struct {
	ID    int    `json:"id"` //结构体标签，json:"id" 表示json序列化时，字段名是id
	Name  string `json:"name"`
	Age   int    `json:"age"`
	score int    // 私有字段不能被json访问
}
func main() {
	s := Student{
		ID:   1,
		Name: "张三",
		Age:  19,
        score: 100,
	}
	// 序列化
	byteJson, _ := json.Marshal(s)  // byte类型的切片
	jsonstr := string(byteJson)
	fmt.Println(jsonstr)
	// 反序列化
	var s2 Student
	json.Unmarshal([]byte(jsonstr), &s2)
	fmt.Println(s2)
}
```

复杂结构体的序列化与反序列化
```go
type Student struct {
	ID   int    `json:"id"` //结构体标签，json:"id" 表示json序列化时，字段名是id
	Name string `json:"name"`
	Age  int    `json:"age"`
}
type Class struct {
	ID       int       `json:"id"`
	Students []Student `json:"students"`
}

func main() {
	c := Class{
		ID:       1,
		Students: []Student{},
	}
	for i := 0; i < 10; i++ {
		c.Students = append(c.Students, Student{
			ID:   i,
			Name: fmt.Sprintf("stu_%d", i),
			Age:  18 + i,
		})
	}
	byteSlic, _ := json.Marshal(c)
	fmt.Println(string(byteSlic))
}
```