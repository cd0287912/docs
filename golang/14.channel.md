### GO channel

进程：程序在操作系统里面运行的一个实例，每个进程都有自己的内存空间和系统资源。

线程：进程内部的一个执行单元，每个进程可以有多个线程，线程共享进程的内存空间和系统资源。

并发：多个线程同时竞争一个位置，竞争到的才可以执行，每个时间段只能有一个线程执行。

并行：多个线程可以同时执行，每一个时间段，可以有多个线程同时执行。

通俗的讲，多线程程序在单核cpu上面运行就是并发，在多核cpu上面运行就是并行。如果线程数大于cpu核数，那么多线程程序在多个cpu上面既有并发，也有并行。

golang中的主线程，在一个golang程序的主线程上可以起多个协程。golang中多个协程可以实现并发或者并行。


```go
func test() {
	for i := 0; i < 10; i++ {
		fmt.Println("test 协程执行中...", i)
		time.Sleep(50 * time.Millisecond)
	}
}
func main() {
	go test()
	for i := 0; i < 10; i++ {
		fmt.Println("main 主线程执行中...", i)
		time.Sleep(50 * time.Millisecond)
	}
}
```

开启多个协程，等待所有协程执行完毕，我们使用`sync.WaitGroup`来实现。

```go
var wg sync.WaitGroup

func test1() {
	for i := 0; i < 10; i++ {
		fmt.Println("test1 协程执行中...", i)
		time.Sleep(50 * time.Millisecond)
	}
	wg.Done()
}
func test2() {
	for i := 0; i < 10; i++ {
		fmt.Println("test2 协程执行中...", i)
		time.Sleep(50 * time.Millisecond)
	}
	wg.Done()
}
func main() {
	wg.Add(1)
	go test1()
	wg.Add(1)
	go test2()

	wg.Wait()
	for i := 0; i < 10; i++ {
		fmt.Println("main 主线程执行中...", i)
		time.Sleep(50 * time.Millisecond)
	}
}

```

练习：测试1到120000之间的素数耗时

for循环版本
```go
func main() {
	start := time.Now().Unix()
	for i := 2; i < 120000; i++ {
		for j := 2; j < i; j++ {
			if i%j == 0 {
				break
			}
		}
	}
	end := time.Now().Unix()
	fmt.Println("耗时:", end-start)
}
```

携程版本
```go
var wg sync.WaitGroup
func star(n int) {
	for i := (n-1)*30000 + 1; i < n*30000; i++ {
		for j := 2; j < i; j++ {
			if i%j == 0 {
				break
			}
		}
	}
	wg.Done()
}
func main() {
	start := time.Now().Unix()
	for i := 1; i <= 4; i++ {
		wg.Add(1)
		go star(i)
	}
	wg.Wait()
	end := time.Now().Unix()
	fmt.Println("耗时:", end-start)
}
```

channel 管道
channel 是 golang 中的一种数据结构，用于在 goroutine 之间传递数据。channel 是一种引用数据类型，它可以用于发送和接收数据。channel 是一种先进先出（FIFO）的数据结构。
channel 可以用于在 goroutine 之间传递数据，也可以用于在 goroutine 之间同步。
channel 可以分为两种类型：有缓冲的 channel 和无缓冲的 channel。
有缓冲的 channel 可以在 channel 中存储多个数据，无缓冲的 channel 只能存储一个数据。

```go
func main() {
	ch := make(chan int, 10) // 定义一个有缓冲的 channel，缓冲区大小为 10
	ch <- 1                  // 写入管道
	ch <- 2
	c1 := <-ch // 读取管道
	c2 := <-ch
	close(ch) // 关闭管道
	fmt.Println(c1, c2)
}
```