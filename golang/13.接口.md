### GO interface

Golang中的接口是一种抽象数据类型，接口定义了对象的行为规范，只定义不实现，由具体的对象实现。
接口是一种类型，是一组函数的结合，接口不包含任何变量。

```go
// 接口的定义
// type 接口名 interface {
//    方法名(参数列表1) 返回值列表1
//    方法名(参数列表2) 返回值列表2
// }

type Usber interface {
	start()
	stop()
}
type phone struct {
	name string
}

func (p phone) start() {
	fmt.Println(p.name, "start")
}
func (p phone) stop() {
	fmt.Println(p.name, "stop")
}

func main() {
	var p1 Usber = phone{name: "APPLE"}
	p2 := phone{name: "HUAWEI"}
	p1.start()
	p1.stop()
	p2.start()
	p2.stop()
}
```

在golang中接口可以不定义任何方法，这个接口称为空接口。空接口表示没有任何约束，因此任何类型变量都可以实现空接口。
用空接口表示任何类型。

```go
type A interface{}

func main() {
	// var a A 
	var a interface{}
	str := "你好"
	a = str
	fmt.Printf("a is %v, a type is %T\n", a, a)
	number := 20
	a = number
	fmt.Printf("a is %v, a type is %T\n", a, a)

	flag := true
	a = flag
	fmt.Printf("a is %v, a type is %T\n", a, a)
}
```

空接口的应用

```go
// 作为函数的参数，接收任意类型的参数
func show(a interface{}) {
	fmt.Printf("a is %v, a type is %T\n", a, a)
}

// 用作map的值类型，接受任意类型的值
type any interface{}
func main() {
	v1 := make(map[string]any)
	v1["name"] = "张三"
	v1["age"] = 18
	v1["flag"] = true
	fmt.Printf("v1 is %v, v1 type is %T\n", v1, v1)
}

// 切片的元素类型可以是任意类型
func main() {
	slice := make([]interface{}, 0, 10)
	slice = append(slice, "你好")
	slice = append(slice, 20)
	slice = append(slice, true)
	fmt.Printf("slice is %v, slice type is %T\n", slice, slice)
}
```

空接口断言
```go
func main() {
	var s interface{} = "golang"
	v, ok := s.(string)
	if ok {
		fmt.Printf("v is %v, v type is %T\n", v, v)
	} else {
		fmt.Println("类型断言失败")
	}
}
```