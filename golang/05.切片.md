### GO 切片

切片是一个拥有相同类型元素的可变长度的序列。它是基于数组类型做的一层封装。
切片是一个引用类型，它的内部结构包含地址、长度和容量。

切片的定义

```go
    // 声明切片 var name []T
    var name []int = []int{1, 2, 3}
	fmt.Println(name)

    // 简写
    age := []int{18, 19}
	fmt.Println(age)


    // 基于数组定义切片
    var a = [...]int{1, 2, 3, 4, 5}
	b := a[:]
	fmt.Println(b)

    // 基于切片的切片
    var a = []int{1, 2, 3, 4, 5}
	b := a[2:4]
	fmt.Println(b) //[3,4]

    // 基于make函数   make([]T, size, cap)
    slice := make([]int, 4, 8)
	fmt.Println(slice) // [0 0 0 0]
```

切片的长度&容量
切片拥有自己的长度和容量【长度指它包含的元素个数， 容量指从它的第一个元素开始数，到其底层数组元素末尾的个数】
我们使用 len 函数求长度，cap 函数求容量

```go
	arr := []string{"a", "b", "c", "d", "e", "f"}
	fmt.Printf("长度%d,容量%d\n", len(arr), cap(arr))  //长度6,容量6

    a := arr[2:]
    fmt.Printf("长度%d,容量%d\n", len(a), cap(a))  //长度4,容量4

	s := arr[2:4]
	fmt.Printf("长度%d,容量%d\n", len(s), cap(s))  //长度2,容量4

```

切片的本质
是对底层数组的封装，它包含三个信息：底层数组的指针、切片的长度、切片的容量

切片操作

```go
	age := make([]int, 0, 0)
	fmt.Println(age) // [0]
    // 添加数据
    age := make([]int, 0, 0)
    fmt.Printf("%v,长度%d,容量%d\n", age, len(age), cap(age)) // [],长度0,容量0
	age = append(age, 18)
    fmt.Printf("%v,长度%d,容量%d\n", age, len(age), cap(age)) // [18],长度1,容量1
	age = append(age, 19, 20)
	fmt.Printf("%v,长度%d,容量%d\n", age, len(age), cap(age)) // [18 19 20],长度3,容量3

    // 合并切片
	sliceA := []string{"a", "b", "c"}
	sliceB := []string{"d", "e"}
	sliceA = append(sliceA, sliceB...)
	fmt.Printf("%v,长度%d,容量%d\n", sliceA, len(sliceA), cap(sliceA)) // [a b c d e],长度5,容量6

    // 切片扩容策略，容量扩大两倍
	sliceA := make([]int, 0, 0)
	fmt.Printf("%v,长度%d,容量%d\n", sliceA, len(sliceA), cap(sliceA))
	for _, v := range [...]int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10} {
		sliceA = append(sliceA, v)
		fmt.Printf("%v,长度%d,容量%d\n", sliceA, len(sliceA), cap(sliceA))
	}
```

切片是引用数据类型，所以赋值修改操作会影响到原切片

```go
	sliceA := make([]int, 10, 10)
	sliceB := sliceA
	sliceB[0] = 1
	fmt.Printf("%v,长度%d,容量%d\n", sliceA, len(sliceA), cap(sliceA))
	fmt.Printf("%v,长度%d,容量%d\n", sliceB, len(sliceB), cap(sliceB))

    // 是否会影响同步修改，主要看是否底层指向同一个数组
    // appeend操作，看是否能容纳，不能则为其分配新的底层数组，并将原有元素复制过去，然后返回新的切片
    // 例子
	sliceA := make([]int, 1, 1)
	sliceB := sliceA
	sliceA[0] = 3
    // [3],长度1,容量1
	fmt.Printf("%v,长度%d,容量%d\n", sliceA, len(sliceA), cap(sliceA))
    // [3],长度1,容量1
	fmt.Printf("%v,长度%d,容量%d\n", sliceB, len(sliceB), cap(sliceB))

	sliceA = append(sliceA, 1)

    // [3 1],长度2,容量2
	fmt.Printf("%v,长度%d,容量%d\n", sliceA, len(sliceA), cap(sliceA))
    // [3],长度1,容量1
	fmt.Printf("%v,长度%d,容量%d\n", sliceB, len(sliceB), cap(sliceB))

	sliceA[0] = 4

    // [3],长度1,容量1
	fmt.Printf("%v,长度%d,容量%d\n", sliceA, len(sliceA), cap(sliceA))
    // [3],长度1,容量1
	fmt.Printf("%v,长度%d,容量%d\n", sliceB, len(sliceB), cap(sliceB))
```

复制切片-深拷贝

```go
    // 复制
    sliceA := []int{1, 2, 3}
	sliceB := make([]int, 3, 3)
	copy(sliceB, sliceA)
	fmt.Println(sliceB)

    // 删除
```
